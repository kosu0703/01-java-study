package com.ict.day08;

public class Ex06 {
	/*
	 	클래스
	 	
	 	1. 정의 : 객체 (Object) 를 만들기 위한 모든 정보를 가지고 있는 파일 (설계도면, 거푸집 등으로 표현)
	 	
	 	2. 클래스가 가지고 있는 것
	 		- 멤버 필드 : 변수와 상수 / 데이터 / 속성
	 		- 멤버 메소드 : 기능 / 동작 
	 		- 생성자 : 클래스가 객체로 생성될때 한번 호출된다.
	 		 	(생성자 이름 = 클래스 이름 = 파일 이름 = 저장 이름)	
	 	
	 	3. 클래스 구조
	 		: 헤더, 멤버필드, 멤버메서드, 생성자
	 		
	 		1) 헤더 : [접근제한자] [클래스종류] class 클래스이름{}	 
	 						   	 			
	 			가) 접근제한자 : 클래스, 멤버필드, 멤버메서드, 생성자 모두 맨 앞에 사용 가능 (생략 가능)
	 						외부에서 접근할 수 있는 권한의 단계를 말함	
	 						 	
	 				- public : 누구나 다 접근가능	 	
	 							
	 				- private : 외부에서는 절대 접근 불가
	 							내부멤버(클래스 안에 있는 멤버필드와 메서드)끼리는 접근가능	 
	 												
	 				- 생략(default) : 같은 패키지에서만 접근 가능	
	 				 				
	 				- protected : 같은 패키지에서 접근 가능
	 							  다른 패키지일때는 상속관계에서만 가능	
	 							   							  
	 			나) 클래스종류 : 일반적인 클래스는 생략한다.				  
	 						특정 클래스에 해당하는 클래스에게만 예약어를 사용 (final, abstract, ...)	 						
	 			
	 			다) class : 클래스임을 나타내는 예약어	
	 			 			
	 			라) 클래스이름 : 클래스 이름 = 파일 이름 = 저장 이름 = 생성자 이름
	 						첫글자는 대문자, 두 단어 이상일때는 단어 첫글자들은 대문자
	 						숫자는 중간이나 뒤에 사용, 공백문자 사용 불가
	 						
	 		2) 멤버필드 : 특징, 속성, 상태값, 데이터
	 			 			
	 			가) 변수 : 언제든지 변할 수 있는 속성, 상태값, 데이터	
	 			 			
	 			나) 상수 : 한번 지정하면 절대로 변경할 수 없는 속성, 상태값, 데이터
	 		
	 		3) 멤버메서드 : 동작, 기능 	
	 				
	 			- 대부분이 public 이다.
	 				
	 			- 해당 메서드를 호출하면 해당 메서드 안에 존재한 내용이 실행된다.	 			
	 			
	 			- **내용이 실행 된 후 끝나면 호출한 곳으로 되돌아 간다.
	 			 
	 			- 메서드가 다른 메서드를 호출할 수 있다.
	 			
	 			가) 메서드 구성
	 				[접근제한자] [메서드종류]  반환형  메서드이름( [인자 or 매개변수] ) { 실행내용 }
	 				
	 				a) 접근제한자 : 클래스 설명에서의 접근제한자와 같다.
	 				
	 				b) 메서드종류 : 일반적인 메서드는 생략한다.
	 							특정 메서드일 때 해당 예약어를 사용 (static 예약어)
	 				
	 				c) **반환형 : 해당 메서드가 실행이 끝나면 호출한 곳으로 되돌아 간다.
	 						   되돌아 갈때 정보를 가지고 갈 수 있는데, 이때 이 정보의 자료형을 말한다.
	 						   만약에 정보를 가지고 가지 않을 때는 void 라는 예약어를 사용한다.	

				 			예)	메인 메서드 : 해당 메서드를 실행한 후에 호출한 JVM 으로 되돌아 가는데 
				 						  아무것도 가져가지 않는다. 
				 				public static void main(String[] args){}	
	 				
	 				d) 메서드이름 : 첫글자 소문자, 두 단어이상 일때는 단어 첫 글자들은 대문자
	 							괄호 ([인자=매개변수]) 앞에 이름이 붙는다.
	 				
	 				e) 인자(매개변수) : 메서드가 실행할 때 필요한 정보를 외부에서 받기 위한 통로 
	 					
	 					** 메서드이름이 같아도 인자 개수나 인자 자료형이 다르면, 다른 메서드로 취급한다.	 					
	 					** 오버로딩(중복정의) : 클래스 안에 같은 이름을 가진 메서드가 여러개 정의되어 있는 것
	 					>>	같은 메서드에 다양한 자료형을 넣어도 같은 결과를 받을 수 있다.	
	 		
	 		4) 생성자 : 클래스가 객체로 만들어질때 한번 호출된다.
	 			
	 			가) 목적 : 멤버필드(변수, 상수)의 초기값을 지정하는 것이 목적
	 			
	 			나) 형식 : 클래스이름과 생성자이름은 같다.
	 					메서드와 다른점은 반환형이 없다.
	 					[접근제한자] 생성자이름(=클래스이름)([인자]){ 실행내용 }
	 					인자가 없는 생성자를 "기본생성자" 라고 한다.
	 					
	 					예)	class Ex06 에서는
	 					   	생성자 > [접근제한자]Ex06([인자]){}
	 					 	기본생성자 > Ex06(){}		
	 
	 					**생성자도 오버로딩이 가능하다.
	 					즉, 하나의 클래스 안에 여러개의 생성자가 존재할 수 있다.
	 					
	 			다) 생성자 없이 클래스를 객체로 생성하면 기본생성자를 호출해서 객체를 만든다.
	 			
	 			라) 모든 클래스는 생성자를 가지고 있다. 
	 			
	 			마) 클래스를 이용해서 객체를 만드는 방법	 			
	 			Scanner	scan	=		   new 			Scanner(System.in);
	 			클래스	    참조변수	=	객체를 만들기 위한 예약어  		생성자
	 				
	 			** new 예약어를 사용하면 무조건 heap 메모리에 사용 영역을 만든다.
	 			즉, 인스턴스, 객체 생성을 의미한다.
	 			
	 			** heap 메모리 : 필요할 때 지웠다 썼다 할 수 있는 동적 메모리
	 		
	 			바) 클래스를 객체로 만든 후 멤버필드와 멤버메서드에 접근하는 방법
	 				: 참조변수.멤버필드 , 참조변수.멤버메서드()	
	 				(단, 접근제한자를 확인하자)				
	 	
	 	4. instance 와 static : 멤버필드, 멤버메서드에 공통으로 해당되는 사항
	 		
	 		1) instance(인스턴스) : 객체 생성
	 			
	 			- 인스턴스필드, 인스턴스메서드 : 객체 생성할때 같이 생성되는 필드와 메서드를 말한다.
	 			
	 			- 일반적인 클래스의 멤버필드나 멤버메서드는 모두 인스턴스이다.
	 			
	 			- 호출 방법 : 참조변수.멤버필드 , 참조변수.멤버메서드()
	 			
	 			- heap 메모리에 만들어진다.
	 			
	 		2) static 
	 		
	 			- 객체 생성과 상관없이 미리 만들어진 멤버필드와 멤버메서드
	 			
	 			- 반드시 static 이라는 예약어를 사용한다.
	 			
	 			- 객체 생성과 상관없이 호출 가능
	 			
	 			- 호출 방법 : 클래스이름.멤버필드 , 클래스이름.멤버메서드()	 			
	 				
	 				예) System.out , Math.max()
	 				 			
	 		**지역변수(메서드 인자에 만들어진 변수) : 해당 메서드가 실행 될 때 만들어진다.
	 		  							  객체 생성할 때는 만들어지지 않는다.	
			
			**지역변수의 이름이 전역변수의 이름과 같을 경우에는 지역변수가 우선권을 가진다.
			
		5. 메모리
			
			1) 스태틱(static) : 프로그램이 시작 전부터 끝까지 존재하는 메모리 영역
			
       		2) 힙(heap) : 프로그램이 시작할때는 있거나 중간에 만들어졌다가 
                    	 어느 순간에는 없어진다. (동적할당)
                   		 자기할일을 다하면 사라진다.  
                   		 
       		3) 스택 : heap 영역에 생성된 Object 타입의 데이터의 참조값이 할당된다.  
              		원시타입의 데이터가 값과 함께 할당된다.
              		원시타입(byte,short,int,log,double,float,boolean,char)타입의 데이터들이 할당된다. 
              		이때 원시타입의 데이터들에 대해서는 참조값을 저장하는 것이 아니라 실제 값을 stack에 직접 저장하게 된다. 
	 						
	 						
	 						
	 						
	 						
	 						
	 						
	 */
	
	
	
	
}
